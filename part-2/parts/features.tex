% I'm not totally sure, if this should be described together or seperate, but somehow or SCRUM approach and the Redmine
% stuff should be mentioned somewhere before the developing part and as this are probably only three pages or somethin
% it probably could be integrated here
\chapter{Features}\label{chap:features}

\section{Notifications and Comments}

The following section describes an important part for registered users, the notification system and the opportunity for adding comments basically on any resource in the system.

\subsection{Recent activity stream}
It displays the most recent events in the portal in the order they happened. Each activity (figure \ref{fig:activity-stream-single-activity}), one line in the stream, consists of 3 parts: meta information about the activity itself, information about the initiator and comments. The content of each of these parts is being determined automatically, when a new notification is being persisted to the database.

Besides the initiator information and comments, each activity has an own title, description and icon. These meta information texts can be edited in the portal in the 'Administration' > 'Acions' section. Although it is not possible to remove them, because the action references are being used hard-coded within the system. That means a set of notifications is provided and can be ouput anywhere in the workflow.

\begin{figure}[!h]
  \centering
  \fbox{
    \includegraphics[width=0.97\textwidth]{images/feature-activity-stream.png}
  }
  \caption{Single activity in the activity stream}
  \label{fig:activity-stream-single-activity}
\end{figure}

The following code snippet shows, how to create a new notification when a new automatic plagiarism detection report was created. The static method takes in 3 parameters: a unique name for the notification type, the content object related to the notification and a user object, as the third parameter. A list of all available notification types can either be found in the previousely mentioned actions section or in the scripts/build/initdb.php file, where all notifcation types are being declared.

\begin{lstlisting}[caption=Creating a notification for a created report]
Unplagged_Helper::notify("detection_report_created", $report, $report->getUser());
\end{lstlisting}

Unplagged does have an extensive role and permission management. Therefore the grant on each resource is being verified, before it is being displayed in the activity stream. Usually the resource related to the notification is the resource where the permission check is being performed on. Although in some cases, e.g. when rating a fragment, the resource will be the rating itself, but the permission check is done on the fragment. In this case the notify-method is being called with a fourth, optional parameter, another resource, in this case the fragment. When the user has access on the fragment, all ratings can be accessed as well, automatically.

\subsection{Comments plugin}

Comments are simply a small text related to a specific user and a resource. They can be used to share ideas on an object collaboratively. The most prominent part at Unplagged, where comments are being used, is the activity stream. A comment can be added by any user having access to the notification. 

\begin{figure}[!h]
  \centering
  \fbox{
    \includegraphics[width=0.97\textwidth]{images/feature-comment.png}
  }
  \caption{Creating a comment on a resource}
  \label{fig:creating-a-comment}
\end{figure}

For providing a better workflow to the user, the comments can be refreshed and added in place. That means, the position where the user scrolled to in the browser does not get affected. The in-place refreshing is being realized through AJAX. The comments container is being loaded empty and displaying a small loading image only. Not before the user clicks the 'show conversation' button, the comments are being fetched through a post request to the server. Whenever the result is being fetched completely, the spinner graphic is being hidden and the comments are being appended. The parsing of the comments markup is being done in Javascript as well. So the server requests are kept small and the server can return JSON only without any HTML.

\begin{lstlisting}[caption=Refreshing the comments of a resource]
	target.show();
      conversation.hide();
      loading.slideDown(800, function() {
        // get the whole conversation
        $.post('/notification/conversation', {
          'source': sourceId
        }, function(data) {
          if(!data.errorcode) {
            conversation.html("");
            $.each(data, function(index, value) {
              conversation.append(renderConversation(value));
            });
            loading.slideUp(800, function() {
              conversation.slideDown(300);
            });
          } else {
            conversation.html('<div class="comment">' + data.message + '</div>');
            loading.slideUp(800, function() {
              conversation.slideDown(300);
            });
          }
        }, "json");
\end{lstlisting}

\begin{lstlisting}[caption=Creating the markup of a single comment]
function renderConversation(data, target) {
    var tpl;
    
    switch(data.type) {
      case 'comment':
        tpl = '<div class="comment">' +
        '<div class="image"><img class="avatar-small" src="' + data.author.avatar + '" /></div>' +
        '<div class="details">' +
        '<div class="title"><b>' + data.author.username + '</b> ' + data.text + 
        ' <span class="date">' + data.created.humanTiming + '</span>' +
        '</div>' +
        '</div>' +
        '</div>';
        break;
    }
    if(!target) {
      return tpl;
    } else {
      target.append(tpl);
    }
  }
\end{lstlisting}

\section{Fragments}

Fragments are the part of the application where found text passages that are plagiairism or potential plagiarism are being documented.

A single fragment contains a candidate and a source document. Each of the two documents is being saved with a starting position (page number / line number combination) and an ending position. These two positions can be used to determine exactly the text being involved in a fragment. To visualize this, the figure \ref{fig:single-fragment}) below shows a sample fragment.

\begin{figure}[!h]
  \centering
  \fbox{
    \includegraphics[width=0.97\textwidth]{images/feature-fragment.png}
  }
  \caption{Single fragment with highlighted similarities}
  \label{fig:single-fragment}
\end{figure}

\subsection{Creating a fragment}

Such a fragment can be created in two ways, one for people that like using the mouse and another one that can be used with the keyboard only.

\textbf{The old-fashioned way}

The basic way, which can be accessed through the keyboard only, offers a two-column form to the user where the source and potential plagiarism information can be selected by hand. Once a page or line number is being changed, the text shown below is being updated instantly through AJAX and the similarities are highlighted automatically. Although the big disadvantage of this method is, that the whole page is never displayed and the user actually has to guess where the starting and ending point of the fragment in the text really is. Therefore the values of the line from and line to fields have to be increased or decreased by hand, until they are adjusted properly.

\begin{figure}[!h]
  \centering
  \fbox{
    \includegraphics[width=0.97\textwidth]{images/fragment-form.png}
  }
  \caption{Form for creating a fragment by hand}
  \label{fig:fragment-form}
\end{figure}

\textbf{A more comfortable workflow}

Wouldn't it be cool to select text by just marking it with the mouse and having this previousely described form being filled out automatically? We though it would, so we implemented it. 

The user has to go to the document being inspected in the current case, select a page to start with and then hit the button 'Switch to two-column view for fragment creation'. At this point a second document can be selected on the right side and the similarities in both texts are once again being highlighted. In this two-column view it is also possible to iterate through the pages of the left-side or right-side document to compare page 1 from the left with page 2 from the right and page 1 on the left with page 3 on the right just by one click.

When there are sufficient similarities in an area of the page, a fragment can be created by marking the the text, then making a click with the right mouse key to open the context menu and 'set as candidate/source of fragment'. This stores the marked text temporarily until the 'create fragment' button in the context menu is being pressed. The selection of the 'create fragment' button opens the same form as described in the section before and pre-fills it with the start and end values for page and line for both sides automatically.

\begin{figure}[!h]
  \centering
  \fbox{
    \includegraphics[width=0.97\textwidth]{images/fragment-modern-way-1.png}
  }
  \caption{Creating a fragment the modern way - Step 1}
  \label{fig:creating-fragment-modern-way-1}
\end{figure}

\begin{figure}[!h]
  \centering
  \fbox{
    \includegraphics[width=0.97\textwidth]{images/fragment-modern-way-2.png}
  }
  \caption{Creating a fragment the modern way - Step 2}
  \label{fig:creating-fragment-modern-way-2}
\end{figure}

\subsection{Rating a fragment}
@benjamin

\section{Barcode}
@benjamin

\section{User avatar}
@elsa

\subsection{Avatar cropping}
@benjamin

\section{Automatic Plagiarism Detection Webservice}
@benjamin
\subsection{PlagAware}
@benjamin

\section{Permission and role management}
@dominik
types of permission, types of roles

\subsection{Collaborators}
@benjamin

new role created from global case role